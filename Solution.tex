\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{floatrow}


\title{\scshape Casper wargame \\ Solutions}
\author{Francesca Del Nin \\ student number: 0734630}
\date{December 2018}

\begin{document}
\maketitle


\section{Overview}
\begin{table}[]
\begin{tabular}{lll}
 Level & Password & Time spent  \\
 \hline
 casper4 & zssEylQhyfOdX0H7OOKFxEXG0iY9Y7PL &   \\
 casper41 & qQftts3uK2DjrNxfEPzXTyOpB20vMakY &   \\
 casper6 &  &  \\
 casper60 & EoWZv5u7pnBkchLK30vXhiyH1sDexpCB & \\
 casper8 & AAqtUL09LWefJlJFvTg0SpVg0j89DGe2 & \\
 casper80 & 5CS80xbUrxgjbrU3BBS5YslY00qoUd5J & \\
 casper82 & MABIQpR4omrMCmdc7PwxbRNm5EPHzYX5 & \\
 casper10 & BpI02agB8PmOKDI1LRvMeQJWi2GrzgWA &\\
\end{tabular}
\end{table}

\newpage
\section{Casper4 solution}
\subsection{Description}
Program casper4 takes an input from the user and prints a greeting and the input from the user. If no input is provided it prints an explanation on how to use the program and exit.
 

\subsection{Vulnerability}

This program is vulnerable because it calls \texttt{strcpy} function passing the (char) pointer \texttt{s} without doing a bound check on the length of the variable pointed, so it can be longer than 666 byte, which is the length of the \texttt{buf} array in which the content will be copied.

\subsection{Exploit description}

To exploit this level I first needed to know how many characters fill the buffer and overwrite the return address of greetUser. To find this number I used gdb, put a breakpoint inside the greetUser function and runned the program, the address of the buffer is:. Then, by using \texttt{info frame} command I'm able to see at which address is stored the eip register where the return address is stored. The distance between the two is 678 byte, so adding another 4 byte I'm able to make a buffer overflow attack.

I provide as input a string of 682 byte in total composed as following:
\begin{enumerate}
\item 100 NOP,
\item the shellcode (21 byte),
\item some padding, in this case "A"'s but can also be NOP (557 byte),
\item the address of the buffer, retrieved through gdb by placing a breakpoint inside the \texttt{greetUser} function and using the command \texttt{p \&buf} on the server.
\end{enumerate}

%./casper4 $(python -c "print('\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x78\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'+'A'*(674-21)+'\x16\xf4\xff\xbf');")

In this way we fill the whole buffer and we overwrite the return address (and the frame pointer too) of the function, so when the execution of greetUser is done the instruction inside the buffer (so the shellcode) will be executed instead of returning to main. 

The NOP instructions at the beginning of the buffer are to make sure that even if the address of the buffer is not precise (due to the program being run inside gdb), the shellcode will be executed because is preceded just by NOP instructions.

%To find the distance between the buffer and the return address there are tw

\subsection{Mitigation}

\subsection{Advanced level casper41}

This exploit works also with casper41 because it only checks for environment variables which are not used for the exploit. I just need to update the address of the buffer, found using gdb on the binary file of casper41.



\section{casper6}
% ./casper6 $(python -c "print('\x90'*(668-21)+'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x78\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'+'\x01\x98\x04\x08');")


\subsection{Description}

This program prints a greeting to the user when provided an input, it uses a struct composed by a buffer array and a function pointer.

\subsection{Vulnerability}

This program is vulnerable because we can overwrite the function pointer, which is just above the buffer in stack.

\subsection{Exploit description}

\subsection{Mitigation}

\section{casper8}
\subsection{Description}

This level prints a greeting to the user as the other levels, but in this case the stack is non-executable so it's not possible to do a buffer overflow.
\subsection{Vulnerability}

In this case the vulnerability is 

\subsection{Exploit description} 

To make this exploit work I first looked for how many input characters make the program go in segmentation fault, then I verified that I was overwriting also EIP register using the "info frame" command after the execution of strcpy inside greetUser and found out that I need a total of 682 byte to complete overwrite the return address of greetUser.

Then I searched for the address of the \texttt{system} function (which execute a shell command) inside libc, which is loaded because it's included in the program. I used gdb command \texttt{p \&system} while running the program and I found that the address is 0xb7e62310. Since I want to pass as argument to this function the string "/bin/xh", which is not present inside the loaded library, I created a new environment variable (through export MYSHELL=/bin/xh).
 To find out the address in which is stored I used the command \texttt{x/s *((char **)environ)} and went through the variables until I found MYSHELL at   *((char **)environ+19) at the address 0xbfffff3f, so to make it point just to "/bin/xh" without "MYSHELL" the address is 0xbfffff47.
 
To make it a cleaner attack I also searched for the address of the \texttt{exit} function inside the library to pass it as return address of the system function. I used the same command as above and found it at 0xb7e55260.

To make the exploit work I passed a string composed as following:
\begin{itemize}
\item 682-4=678 A's;
\item \texttt{system} function address (endian encoded);
\item \texttt{exit} function address (endian encoded);
\item the address of the string "/bin/xh".
\end{itemize}

This attack worked inside gdb but not outside because the address of the environmental variables can change a bit, the error displayed was telling "bin/xh: not found" so the string passed was missing a "/". Changing the address of the string to 0xbfffff46 did the trick.

\subsection{Mitigation}

\subsection{Advanced level casper80}

The same approach work also for this advanced level because it only checks for NOP in the input. To make it work I checked again the distance from the buffer to the return address of \texttt{greetUser} function, this time it has changed to 682 byte (so 686 to overwrite it). I also changed the address of the string because the address of the environmental variable MYSHELL changes a bit, to make it work I used 0xbfffff44. To get this value I read the error message displayed with the address used in the other exploit and there where two characters missing.

\subsection{Advanced level casper82}

The same approach works also for casper82, because it checks for ASCII characters just for the length of the buffer, so if I fill the whole buffer with A's and only after use the ascii characters to overwrite the return address the attack will still work. The exploit in this case is exactly the same as casper80.

\end{document}